# Домашнее задание к занятию "6.6. Troubleshooting"

1. MongoDB

   Для нахождения и остановки долгих запросов можно использовать следующий подход

   ```js
   db.currentOp().inprog.forEach(function (op) {
     if (op.secs_running > 180) printjson(op);
   });
   ```

   После чего по ключу `op.opid` можно остановить запрос

   ```js
   db.killOp(op.opid);
   ```

   Для оптимизации подобных запросов я бы предложил следующие подходы:

   - Добавить индекс `db.<table>.createIndex({})`;
   - Использовать проекции для выборки только нужных данных из таблицы;
   - Добавлять к запросам метод `maxTimeMS` для автоматического вызова `db.killOp()` при слишком долгом выполнении запроса.

2. Redis

   Я считаю что для начала надо проверить через `redis-cli` показатель `latency` и задержки самой `VM`, проверить `slowlog` нет ли в нем медленных команд, отключить `huge_page` в настройках ядра, так же, если добавленные реплики расположены на других хостах и общение между репликапи происходит по сети, а не через Unix socket, то уместным будет проверить задержки на уровне сети.

3. MySQL

   Данная ошибка происходит из-за слишком долгой обработки запроса и `MySQL` просто рвет соединение по таймауту. Решением может быть увеличение таймаутов, оптимизиция самого запроса к базе данных, разбиение больших таблиц, добавление индексов, возможно даже увеличение ресурсов самого хоста.

4. PostgreSQL

   `OOM-Killer` это системный процесс, который вызывается в тот момент когда у ядра системы начинается так называемая "паника" из-за нехватки памяти. Таким образом `OOM-Killer` пытается обрушивает процессы потребляющие много памяти ради того что бы спасти ОС. Решением может быть от банального добавления памяти системе, до настроек ядра, таких как `vm.overcommit_memory`, либо выключения `OOM-Killer`, что естественно не рекомендуется.