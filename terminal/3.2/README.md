# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

1. С помощью команды `type cd` можно узнать, что, `cd is a shell builtin` из чего можно понять что, `cd` это встроенная команда в `bash` для навигации по файловой системе
2. Альтернатива команде `grep <some_string> <some_file> | wc -l` без использования `pipe` это `grep` с параметром `-c`, например `grep -c <some_string> <some_file>`
3. Процесс с PID 1 это `systemd` - системный и сервисный менеджер, который создает и поддерживает все последующие службы
4. Немного не понял что имеется ввиду `другую сессию`, я понял примерно так `ls 'nothing' 2> /proc/<process_id>/fd/2`
5. Если я правильно понял вопрос, то должно быть что-то вроде `cat file > echo > new_file`
6. Я немного не понял вопрос, если имеется ввиду ситуация схожая с вопросом #12, то да, сможем и увидим.
7. Сначала мы сказали перенаправлять bash'у все что идет из потока 5 в поток 1 (stdout), затем с помощью `echo` отправили текст в 5 поток, который и увидели в своем stdout, т.е. на экране терминала
8. Для `pipe` stderr без потери `stdout` нужно сделать прмиерно следующее `some_command > file 2>&1 | do_something`, `file` указан в качестве примера, куда перенаправить `stdout` будет зависеть от задачи
9. Команда `cat /proc/$$/environ` выведет переменные среды для текущей сессии, еще это можно узнать с помощью `env`
10. `/proc/<PID>/cmdline` - содержит полную командную строку для процесса, если только процесс не является зомби, иначе возвращает пустую строку. `/proc/<PID>/exe` - В Linux 2.2+ по этому пути содержится ссылка на фактически исполняемую команду, вызвав `/proc/<PID>/exe` можно запустить еще одну копию исполняемого файла, в Linux 2.0 и более ранних версиях содержал указатель на исполняемый двоичный файл в формате `[<major><minor>] <index>`, где `major` - это устройство (диск), `minor` - раздел на устройстве, `index` - индекс на данном устройстве, например `[0101]: 1111`
11. С помощью команды `cat /proc/cpuinfo | grep sse` можно получить всю информацию где содержится ключевое слово `sse` из чего можно сделать вывод, что самая старшая поодерживаемая версия инструкций SSE на моем процессоре это - [SSE-4.2](https://en.wikipedia.org/wiki/SSE4#SSE4.2)
12. Это происходит из-за того что при попытке выполнить команду `tty` удаленно через `SSH`, например `ssh localhost 'tty'`, `tty` не выделяется, для принудительного выделения `tty` необходимо использовать ключ `-t` в таком случае псевдотерминал выделится принудительно, даже если у текущего `SSH` его нет.
### 
14. Команда `tee` из мануала `man tee`, читает из `STDIN` и пишет в `STDOUT`, таким образом пример `echo string | sudo tee /root/new_file` будет работать так как `shell` перенаправит поток в `STDIN` команды `tee` которой мы в свою очередь уже от `root` говорим писать в файл `/root/new_file`