# Домашнее задание к занятию "3.3. Операционные системы, лекция 1"

1. Команда `cd` делает системный вызов, который проверят переданный ей путь на то, что он директория и то, что у нас хватает прав на нее и в случае успеха переходит в эту директорию, где проверка на `0` означает успешное выполнение

   ```sh
   stat("/tmp", {st_mode=S_IFDIR|S_ISGID|0775, st_size=219, ...}) = 0
   chdir("/tmp") = 0
   ```

2. База данных команды `file` находится в `/usr/share/misc/magic.mgc`, так же по мимо прочего команда `file` пытается проверить информацию о файле по следующим путям `~/.magic.mgc`, `~/.magic`, `/etc/magic.mgc` и `/etc/magic`
3. На сколько я понял вопрос:

   <test.sh>

   ```bash
   #!/bin/bash

   echo_value=$1
   echo_count=$2

   if [[ -z "$echo_count" ]]; then echo_count=30; fi;

   if [[ ! -z "$echo_value" ]]; then
    for (( i=1; i<=$echo_count; i++ )); do
     echo "$i: $echo_value";
     sleep 1;
    done;
   else
    echo "example: $0 <some_value> [repeat_cout (default: 30)]";
   fi
   ```

   ```bash
   $ ./test.sh "Hello world" 10000 > test.log &
   $ <PID>
   $ rm -f test.log
   $ lsof -p <PID>
   ```

   то мы увидим `cat /proc/<PID>/fd/1` удаленный файл в который действительно продолжают писаться логи, если нет возможности вызвать `kill`, то мы можем очистить или вызвать `truncate` для данного файла с помощью `echo "" > /proc/<PID>/fd/1` или `: > /proc/<PID>/fd/1`

4. Зомби-процессы не занимают ресурсы в ОС (CPU, RAM, IO), они блокируют записи в таблице процессов, размер которой ограничен
5. За первые секунды работы утилиты

   | PID  | COMM        | FD  | ERR | PATH                                    |
   | ---- | ----------- | --- | --- | --------------------------------------- |
   | 1027 | vminfo      | 5   | 0   | /var/run/utmp                           |
   | 561  | dbus-daemon | -1  | 2   | /usr/local/share/dbus-1/system-services |
   | 561  | dbus-daemon | 18  | 0   | /usr/share/dbus-1/system-services       |
   | 561  | dbus-daemon | -1  | 2   | /lib/dbus-1/system-services             |
   | 561  | dbus-daemon | 18  | 0   | /var/lib/snapd/dbus-1/system-services/  |

   Откуда видно обращения к файлу содержащему информацию о текущих пользователях вошедших в систему, в моем случае это обращения от сервиса VirtualBox'а, а так же обращения системы Dbus (шина служащая для общения программ друг с другом) к своим системным файлам

6. Команда `uname` обращается к системному вызову `uname(2)` который возвращает структуру определенную в `<sys/utsname.h>`, так же часть информации utsname доступна через `/proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}`
7. Разница между `;` и `&&` в том что с помощью `;` мы будем просто задавать последовательность команд которые надо выполнить (слева на право), в то время как `&&` это логический операнд `AND`. В первом случае при использовании `;` вся последовательность выполнится в любом случае вне зависимости от результата выполнения каждой из команд или проверок, тогда как при использовании `&&` последовательность будет прервана, если хотя бы одна команда или проверка не вернет `code 0` или `True`.

   Команда `echo` выполнится в любом случае

   ```bash
   test -d /tmp/some_dir; echo "Hello world"
   ```

   Команда `echo` выполнится только в том случае, если директория `/tmp/some_dir` существует

   ```bash
   test -d /tmp/some_dir && echo "Hello world"
   ```

   Как видно из `set --help` смысл в `&&` пропадет, если применить `set -e`, так как `-e Exit immediately if a command exits with a non-zero status.` завершит сессию если хотя бы одна команда не вернет `code 0`

8. Как следует из предыдущего вопроса, ключ `e` прекратит цепочку команд, если хотя бы одна не вернул `code 0`, ключ `u` будет считать все неустановленные параметры за ошибку, `x` - будет выводить на печать команды и их аргуметы по мере их выполнения, `o pipefail` будет возвращать статус последней команды вернувшей ошибку, либо `0` если ни одна команда не вернула ошибку. Данный режим хорошо использовать, так как он обеспечивает последовательность вывода информации в консоль, а так же гарантирует при получении `code 0`, что все команды вернули данный код
9. Наиболее часто встречающийся статус это `S` - прерываемый сон, процесс ждет события завершения другого процесса, так же часто встречаются процессы со статусом `R` - процесс запущен или в очереди на запуск и `I` - неактивный поток ядра, при операциях ввода/вывода могут встречаться процессы со статусом `D` - неприрываемый сон, процесс ждет завершения чтения/записи. Так же у процессов могут встречаться дополнительные ключи, такие как `<` - высокоприоритетный процесс, `N` - низкоприоритетный процесс, `s` - процесс инициировавший сессию
